<html>
    <head>
		<script type="text/javascript" src="sylvester-0-1-3/sylvester.js"></script>
		<script type="text/javascript" src="glUtil.js"></script>
        <script type="text/javascript" src="gl.js"></script>
        <script type="text/javascript" src="mesh.js"></script>
        <script type="text/javascript" src="material.js"></script>
        <script type="text/javascript" src="scenegraph.js"></script>
        <script type="text/javascript" src="mathextras.js"></script>
        <script type="text/javascript">
			var pos_el;
			var rot_el;
			var sca_el;
			function setTextNode(element, text) {
				var currentChild = element.firstChild;
				while (currentChild) {
					if (currentChild.nodeType == currentChild.TEXT_NODE) {
						currentChild.textContent = text;
						return;
					}
					currentChild = currentChild.nextSibling;
				}
				element.appendChild(document.createTextNode(text));
			}
			function LogTransform(position, rotation, scale) {
				setTextNode(pos_el, position);
				setTextNode(rot_el, rotation);
				setTextNode(sca_el, scale);
			}
            function start() {
                var canvas = document.getElementById("glcanvas");
				LogElement = document.getElementById("err_log");
				
				pos_el = document.getElementById("position");
				rot_el = document.getElementById("rotation");
				sca_el = document.getElementById("scale");
				
                initGL(canvas);
				
				var Scene = new SceneObject();
				Scene.name = "Scene";
				
				var testSquare = new SceneObject("Square", Mesh.createSquareMesh(1.0, $V([0, 0, 1]), false));
				testSquare.components.mesh._packArrays();
				testSquare.components.material.addShader(Material.DefaultShader);
				Scene.addChild(testSquare);
				
				var camera = new Camera(45, 640.0/480.0, 0.1, 100.0);
				camera.components.transform.Translate([0, 0, -5]);
				
				testSquare.components.transform.Translate([0.0, 0.0, -5.0]);
				
				camera.SetCameraMatrices(testSquare.components.material);

				Scene.draw();
				
				var lastTime = Date.now();
				var axis = $V([0, 0, 1]);
				
				function update() {
					// clear the color/depth buffers
					gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
					var curTime = Date.now();
					var deltaTime = (curTime - lastTime) / 1000; // time given is ms, get in seconds
					lastTime = curTime;
					var amount = 10 * deltaTime;
					testSquare.components.transform.Rotate(axis, amount);
					//testSquare.components.transform.RotateEuler(amount, amount, amount);
					Scene.draw();
					
					LogTransform(testSquare.components.transform.position.toString(), $V(testSquare.components.transform.rotation()).x(RAD2DEG).toString(), JSON.stringify(testSquare.components.transform.scale));
				}
				window.setInterval(update, 1000/30);
            }
        </script>
		<script id="shader-fs" type="x-shader/x-fragment">
			// specifies floating point precision
			precision mediump float;
			
			varying vec4 oPosition;
			varying vec3 oNormal;
			varying vec2 oUv;
		
			void main(void) {
				// convert the position from range [-1, 1] to [0, 1] for colors
				gl_FragColor = (oPosition + 1.0) * 0.5;
			}
		</script>
		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 position;
			attribute vec3 normal;
			attribute vec2 uv;
			
			varying vec4 oPosition;
			varying vec3 oNormal;
			varying vec2 oUv;
			
			// model matrix (positioning in space of your vertex)
			uniform mat4 modelMatrix;
			// camera positioning
			uniform mat4 viewMatrix;
			// perspective matrix (perspective projection camera)
			uniform mat4 projectionMatrix;

			void main(void) {
				oPosition = vec4(position, 1.0);
				gl_Position = projectionMatrix * viewMatrix * modelMatrix * oPosition;
				oNormal = normal;
				oUv = uv;
			}
		</script>
		<script id="outline-fs" type="x-shader/x-fragment">
			precision mediump float;
			varying vec4 oPosition;
			varying vec3 oNormal;
			varying vec2 oUv;

			uniform vec4 outlineColor;
			
			void main(void) {
				gl_FragColor = outlineColor;
			}
		</script>
		<script id="outline-vs" type="x-shader/x-vertex">
			attribute vec3 position;
			attribute vec3 normal;
			attribute vec2 uv;
			
			varying vec4 oPosition;
			varying vec3 oNormal;
			varying vec2 oUv;
			
			// model matrix (positioning in space of your vertex)
			uniform mat4 modelMatrix;
			// camera positioning
			uniform mat4 viewMatrix;
			// perspective matrix (perspective projection camera)
			uniform mat4 projectionMatrix;

			// uniform specifying how much to scale the mesh for an outline
			uniform float outlineScale;
			
			void main(void) {
				// pass normal, uv, and position through
				oPosition = vec4(position, 1.0);
				oNormal = normal;
				oUv = uv;
				
				// scale the mesh uniformly to make it into an outline
				oPosition = oPosition * outlineScale;
				
				// modify vertex pos by MVP (because col major PVM) matrix
				gl_Position = projectionMatrix * viewMatrix * modelMatrix * oPosition;
			}
		</script>
    </head>
    <body onload="start();">
        <canvas id="glcanvas" width="640" height="480">
            Browser does not support the <code>&lt;canvas&gt;</code> element.
        </canvas>
		<div id="transform">
			<div><span>Position: </span><span id="position"></span></div>
			<div><span>Rotation: </span><span id="rotation"></span></div>
			<div><span>Scale: </span><span id="scale"></span></div>
		</div>
		<div id="err_log" style="overflow: scroll; height: 30em"></div>
    </body>
</html>
